;#// eval "proc test {} {$a$b}"


>puts "$TVIm   $TVI   $TVIp $CountB"



;#//Получение гистерезиса каскада
proc fGetCscdG {} {
upvar #0 CSCD_id CSCD_id;
set CSCD_data [split [fGetProp $CSCD_id] ","];
return [lindex $CSCD_data [ -  [llength $CSCD_data] 3]];
}


;#//Расчет ТВИ при изменение количества котлов в моменте
proc fTestTVI {} {
upvar #0 CountB CountB;
upvar #0 TVI TVI;
set cB [fCountB $CountB];
if {!= $CountB $cB} {
set CountB $cB;
fSetTCas;
fPubSensT TVI $TVI
} else {
set TVI [fCalcTVI $TVI];
fPubSensT TVI [fGetInt $TVI];
}}


;#//Определние количества котлов в каскаде
proc fCountB {CountB} {
upvar #0 TVI TVI;
upvar #0 TVIm TVIm;
upvar #0 TVIp TVIp;
set tvi [fGetInt $TVI];
if {< $tvi $TVIm} {
set TVI 0;
return [min [+ $CountB 1] 3]
} else {if {> $tvi $TVIp} {
set TVI 0;
return [max [- $CountB 1] 1];
} else {
return $CountB};
}}


;#//Отсечение дробной части
proc fGetInt {n} {
return [lindex [split $n "."] 0]
}


;#//Расчет ТВИ
proc fCalcTVI {tvi} {
set cT [fGetCt];
set sT [fGetTt];
set dT [- $cT $sT];
if {>= $dT -10} {
if {< $dT 12} {
set dT 0}};
fPubSensT dTTVI $dT;
return [fGetInt [expr "$tvi + $dT/3"]]}

;#// счетчиков стабилизации системы (исключено)
proc fTVI0 {TVI} {
upvar #0 CountTVI CountTVI;
upvar #0 TVIlast TVIlast;
incr CountTVI;
if {> $CountTVI 360} {
set TVIlast 0;
set CountTVI 0;
return 0;
} else {
if {== $TVI $TVIlast} {
incr CountTVI} else {
set CountTVI 0;
set TVIlast $TVI}};
return $TVI}


;#// Начальная иницыализация счетчиков стабилизации системы (исключено)
set CountTVI 0;
set TVIlast $TVI

;#//Запрос требуемой температуры
proc fGetTt {} {
return [- [CSCD_req] 2770 ]
}


;#//Запрос фактической температуры температуры
proc fGetCt {} {
return [get_t "Подача из гидрострелки"]
}


;#//Создание и назначение значения в сенсор type 1
proc fPubSensT {n v} {
sendmess sel "\{\"name\":\"$n\",\"cmd\":[+ $v 2730],\"type\":1\}"
}


;#// Назначение уставок
proc fSetTCas {} {
upvar #0 CountB CountB;
upvar #0 TVI TVI;
upvar #0 cLsB cLsB;
set sT [fGetTt];
set i 1;
while {<= $i [llength $cLsB]} {
fSetMask $i $CountB $cLsB $sT;
incr i}}


;#// Расчет и применение уставки по списку из "Назначение уставок". Вариант 2
proc fSetMask {i count cLsB sT} {
set mask [fMakMask $i $cLsB];
if {<= $i $count} {  
set sTemp [fS1 $i $sT];
set sTemp [max $sTemp [+ $sT 2720]]
} else {
set sTemp [fS2 $i $sT]};
fRepSet "$mask" $sTemp}


;#// Расчет установки с учетом накопленного дефицита
proc fS3 {i sT} {
upvar #0 TVI TVI;
set x 0;
if {< $TVI 0} {
set x [min [abs [fGetInt [/ $TVI 6]]] 80]
};
return [expr "$sT + 2730 + 100 - 70 * ($i - 1) + $x"]
}

proc fS1 {i sT} {
upvar #0 TVI TVI;
set x 0;
if {<= $TVI 0} {
set x [max [fGetInt [/ $TVI 6]] -80]
} else {
set x [min [fGetInt [/ $TVI 10]] 50];
};
return [ - [expr "$sT + 2730 + 100 - 70 * ($i - 1)"] $x]
}


;#// Расчет установки для котла в дежурном режиме (вне каскада)
proc fS2 {i sT} {
return [- [+ $sT  2730] [* 15 $i]]
}


;#// ЛогРепорт по установкам
proc fRepSet {mask sTemp} {
set_hc_ts "$mask" $sTemp;
puts "[objname $mask] $sTemp ([- $sTemp 2730])"
}

;#// Формирование маски Алиса для текущего i котла
proc fMakMask {i cLsB } {
return [conjoin "|" [lindex $cLsB [- $i 1]]];
}


;#//Запрос состояния объекта по id
proc fGetState {id} {
set s [sendmess sel [conjoin "" "#Y" $id "?"]];
return $s
}


;#// Запрос параметров объекта по id из конфига (строка конфига по id)
proc fGetProp {id} {
set s [sendmess sel [conjoin "" "#Z" $id "?"]];
return $s
}


;#// Запрос id Каскада
set CSCD_id [objid "Каскад котлов" 40];


;//Получение запроса к каскаду
proc fCSCD_req {} {
upvar #0 CSCD_id CSCD_id;
set CSCD_state [split [fGetState $CSCD_id] ","];
set CSCD_req [lindex $CSCD_state [ -  [llength $CSCD_state] 2]];
return $CSCD_req
}


;#// Запрос ведущего котла
proc fIdMain {} {
upvar #0 CSCD_id CSCD_id;
set CSCD_state [split [fGetState $CSCD_id] ","];
set idMain [lindex $CSCD_state [ -  [llength $CSCD_state] 3]];
return $idMain
}


;#// Поучение списка котлов из настроек
proc fLSBoilProp {} {
upvar #0 CSCD_id id;
set s [fGetProp $id];
set LsBoil [split [lindex [split [lindex [split $s "\["] 1] "\]"] 0] ,];
return $LsBoil;
}


;#// Обновление списка котла (мониториг ротации)
proc fUpdateBoilLs {e i n v} {
upvar #0 CountB CountB;
upvar #0 cLsB cLsB;
set cLsB [fCurLsBoil];
fSetTCas
}


;#// Формирование списка котлов по порядку
proc fCurLsBoil {} {
upvar #0 CSCD_id CSCD_id;
set MainBoil [fIdMain];
set lsBoil [fLSBoilProp];
set pos [lsearch $lsBoil $MainBoil];
set LenLsBiol [llength $lsBoil];
return [fSortLsBoil $lsBoil $pos $LenLsBiol]
}


;#// Сортировка котлов "от ведущего"
proc fSortLsBoil {lsBoil pos LenLsBiol} {
return "[lrange $lsBoil $pos [- $LenLsBiol 1]] [lrange $lsBoil 0 [- $pos 1]]"
}


;#// Начальная инициализация каскада котлов
fUpdateBoilLs 1 2 3 4;
setev hou fUpdateBoilLs


;#// Начальная иницыализация лимитов ТВИ
set TVIm "-450";
set TVIp "800";


;#//Работа по таймеру для ТВИ
set TVI 0;
set CountB 1;
set CscdG [fGetCscdG];
settim fTestTVI 10000 1


;#// Получение запроса к каскаду
proc CSCD_req {} {
upvar #0 CSCD_id CSCD_id;
set CSCD_state [split [fGetState $CSCD_id] ","];
set CSCD_req [lindex $CSCD_state [ -  [llength $CSCD_state ] 2]];
return $CSCD_req
}
