Для работы с Modbus, если не прокатило затащить устройство сходу, рекомендуется использования ПК+rs485 <>usb + ModbusPoll или аналогичную связку
https://www.modbustools.com/download.html

Для анализа ответов в побитовом виде удобно использовать:

string dec2hex 256   >>  0100

string hex2dec 0100  >>  256


      proc d2b {n} {
          set binary ""
          while {> $num 0} {
              set bit [% $n  2]
              set binary "$bit$binary"
              set num [/ $n 2]
          }
          return $binary
      }



Функция для просмотра лога - что летит по мб в устройство (и вообще есть ли там что)
________________________
\>proc mbm {i e n v} {
puts $n
}
_____

\>setev mb mbm 
________________________



Пример отправки команды по mb для чтения

\>mbsend 3 1 0 18

Пример отправки команды по mb для записи одного регистра

\>mbsend 6 1 4 1 280


**листинг команды**


**mbsend funk mbslaveAdres REG LEN_data data**

**небольшое how-to для модбас термостатов**


1 подключение термостат в соответствии с руководством (скорости, чётности, стопы)


перезагрузитесь

2. вводите в терминале 

2.1 сообщение:

\>proc mbm {i e n v} {
puts $n
}


2.2 сообщение 

\>setev mb mbm 

2.3 сообщение

>mbsend 3 1 0 ХХ


описание см выше


ХХ надо заменить на данные из руководства на термостат, (посчитать сколько там регистров). Бывает что все регистры _разом не читает_, делим на части вычитываем значения


получаете ответ (количество отдельных данных будет равно ХХ+3) формата:

 
12:50:31 <H 1 2 2305 0 256 7168 0 256 61440 61440 256 37637

данные являются списком, нумерация списка начинается с **0**

значение в первом регистре будет именно индекс 3

этим данные предоставлены в кодированном формате:

истинное значение = NN/256+ остаток(NN,256)*256


открываете эксель и смотрите что за что отвечает, сравнивая с руководством.

   proc f_mbt_sync {} {
 
    set a 1
   
    upvar #0 mbt${a}_n nam
   
    upvar #0 mbt${a}_t  t
   
    set tt [- [get_hc_ts  $nam] 2730]
   
    if {!= $t $tt} {
   
  **set ls "1 1 1 270 0 54 13 3"**;# Номерация с 0!  270 - имеет индекс 3, это целевая темпеература 54 -  минуты, 13 часы, 7 день недели 
  
     lset ls 3 $tt
     
     lset ls 5 [gettime m]
     
     lset ls 6 [gettime h]
     
     lset ls 7 [gettime W]
     
     mbsend 16 1 0 8 $ls;# Тут идет запись пачки регистров функцией 16, в slave addres - 1, адрес первого записываемого 0, длина пакета 8
     
     set t $tt
     
     puts "$ls"
     
    } else {
   
     mbsend 3 1 0 11
   }
 }

Синхронизировать часы и минуты не обязательно, для любых других устройств действия теже - главное правильно собрать **ls**, Если устройства разные, то либо использовать **пространство имен (#.NameSpace)** для каждого типа, либо делить их через if
